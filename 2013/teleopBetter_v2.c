#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     ,               sensorLightActive)
#pragma config(Sensor, S4,     ,               sensorHiTechnicIRSeeker1200)
#pragma config(Motor,  mtr_S1_C1_1,     motorD,        tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     motorE,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     motorF,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     motorG,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C3_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_2,    tip,                  tServoStandard)
#pragma config(Servo,  srvo_S1_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/////////////////////////////////////////////////////////////////////////////////////
//
//	teleopBetter_v2 (6150's TeleOp program)
//
//	This file contains the code to run the TeleOp program for team 6150, the Fractals.
//	Our robot is very quick and our dropping mechanism (consisting of a DC motor and a servo)
//	is fairly accurate. This is because our DC motor's speeds have been dampened. We did this
//	because it allowed our robot to be more stable and accurate when picking up, carrying, and
// 	dropping blocks. Our program is designed so that the robot can do things quickly and
//	efficiently.
//
//	Controls:
//	Joystick 1 (Drivetrain controls)
//	Left Joystick - motorD, a DC motor. Controls one tank tread.
//	Right Joystick - motorE, a DC motor. Controls one tank tread.
//		NOTE - Together, the left and right joysticks make up the tank drive system. We have
//		found this system to be superior when practicing because it allows for good traction
//		and easy handling.
//	A Button - button 2. When pressed, all drive motors stop; a fail-safe in case something
//	goes wrong
//	RT Button - button 8. When pressed, robot moves at "hyperspeed", the maximum speed the
//	motors allow. See above for method behind the madness!
//
//	Joystick 2 (Arm and Servo controls)
//	Left Joystick - motorF, a DC motor. Controls the large arm with the servo attached to it.
//	Right Joystick - motorG, a DC motor. Controls the spinning mechanism on the back for flag
//	lifting.
//	LT Button - button 7. When pressed, the servo with the scoop, slants forward to drop blocks
//	ahead of the robot.
//	RT Button - button 8. When pressed, the servo with the scoop, slants backward to grab blocks
//	into our control
//
//	Thanks for reading!
//	~Team 6150, the Fractals
//
// 	Last modified: Dec 31st, 2013
//	@author - Subash C., Manu S., and Prathosh V.
//
/////////////////////////////////////////////////////////////////////////////////////


#include "JoystickDriver.c";

/**
*	Method stops all driver movement
* in case something goes wrong
*/
void stopAll()
{
	//Sets all motors to zero, stops robot
	motor[motorD] = 0;
	motor[motorE] = 0;
}

task main()
{
	while(true)
	{
		getJoystickSettings(joystick);

		// Calls the stopAll() method to stop motors
		if(joy1Btn(2) == 1)
			stopAll();

		// If trigger is pressed, speed up robot
		while(joy1Btn(8) == 1)
		{
			int leftSpeed = 0; // initialize left and right speeds for
			int rightSpeed = 0; // the drivetrain
			getJoystickSettings(joystick);
			if ( -10 > joystick.joy1_y1 > -100 || 10 < joystick.joy1_y1 < 100) // if the value on base's y1 is not in the deadzone...
			{
				int leftSpeed = joystick.joy1_y1; // sets the speed for the left side
			}

			getJoystickSettings(joystick);
			if ( -10 > joystick.joy1_y2 > -100 || 10 < joystick.joy1_y2 < 100) // if the value on base's y2 is not in the deadzone...
			{
				int rightSpeed = joystick.joy1_y2; // sets the speed for the right side
			}
			// sets the motors now so that they are
			// synchronized; otherwise, left would be in front
			motor[motorD] = leftSpeed;
			motor[motorE] = rightSpeed;

			// joy2 controlling arm and servo movement
			getJoystickSettings(joystick);
			if (-10 > joystick.joy2_y1 > 100 || 10 < joystick.joy2_y1 < 100) // if the arm's y1 value is not in the deadzone...
			{
				motor[motorF] = joystick.joy2_y1/4; // sets the arm motor to move
																					// up for out and down for retract
			}

			getJoystickSettings(joystick);
			if (-10 > joystick.joy2_y2 > -100 || 10 < joystick.joy2_y2 < 100) // if the arm's y2 value is not in the deadzone...
			{
				motor[motorG] = joystick.joy2_y2/4; // move the spinny thing to spin the flag
			}
			// servo movement
			while(joy2Btn(7) == 1) // if left is pressed
				servo[tip] = ServoValue[tip] + 3; // drop blocks in front
			while(joy2Btn(8) == 1) // if right is pressed
				servo[tip] = ServoValue[tip] - 3; // pull scoop behind
		}

		// if trigger is not pressed, slow down robot
		// same as above, but slower
		while(joy1Btn(8) == 0)
		{
			getJoystickSettings(joystick);
			int leftSpeed = 0;
			int rightSpeed = 0;
			if (-10 > joystick.joy1_y1 > -100 || 10 < joystick.joy1_y1 < 100)
			{
				leftSpeed = joystick.joy1_y1/2;

			}
			getJoystickSettings(joystick);
			if (-10 > joystick.joy1_y2 > -100 || 10 < joystick.joy1_y2 < 100)
			{
				rightSpeed = joystick.joy1_y2 / 2;
			}

			motor[motorD] = leftSpeed;
			motor[motorE] = rightSpeed;

			getJoystickSettings(joystick);
			if (-10 > joystick.joy2_y1 > 100 || 10 < joystick.joy2_y1 < 100)
			{
				motor[motorF] = joystick.joy2_y1/4;
			}
			getJoystickSettings(joystick);
			if (-10 > joystick.joy2_y2 > -100 || 10< joystick.joy2_y2 < 100)
			{
				motor[motorG] = joystick.joy2_y2/4;
			}
			while(joy2Btn(7) == 1)
				servo[tip] = ServoValue[tip] + 3;
			while(joy2Btn(8) == 1)
				servo[tip] = ServoValue[tip] - 3;
		}
	}
}
