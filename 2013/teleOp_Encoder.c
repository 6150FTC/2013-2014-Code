#pragma config(Hubs,  S1, HTMotor,  HTServo,  none,     none)
#pragma config(Hubs,  S2, HTMotor,  none,     none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     light,          sensorLightActive)
#pragma config(Sensor, S4,     IR,             sensorHiTechnicIRSeeker1200)
#pragma config(Motor,  motorA,          IRThing,       tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     motorF,        tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     motorG,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C1_1,     motorD,        tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S2_C1_2,     motorE,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C2_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_2,    tip,                  tServoStandard)
#pragma config(Servo,  srvo_S1_C2_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/////////////////////////////////////////////////////////////////////////////////////
//
//	teleOp_Encoder (6150's TeleOp program)
//
//	This file contains the code to run the TeleOp program for team 6150, the Fractals.
//	Our robot is very quick and our dropping mechanism (consisting of a DC motor and a servo)
//	is fairly accurate. This is because our DC motors' speeds have been dampened. We did this
//	because it allowed our robot to be more stable and accurate when picking up, carrying, and
// 	dropping blocks. Our program is designed so that the robot can do things quickly and
//	efficiently.
//
//	Controls:
//	Joystick 1 (Drivetrain controls)
//	Left Joystick - motorD, a DC motor. Controls one tank tread.
//	Right Joystick - motorE, a DC motor. Controls one tank tread.
//		NOTE - Together, the left and right joysticks make up the tank drive system. We have
//		found this system to be superior when practicing because it allows for good traction
//		and easy handling.
//	A Button - button 2. When pressed, all drive motors stop; a fail-safe in case something
//	goes wrong
//	RT Button - button 8. When pressed, robot moves at "hyperspeed", the maximum speed the
//	motors allow. See above for method behind the madness!
//
//	Joystick 2 (Arm and Servo controls)
//	Left Joystick - motorF, a DC motor. Controls the large arm with the servo attached to it.
//	(Also partially controls the servo through motor encoder)
//	Right Joystick - motorG, a DC motor. Controls the spinning mechanism on the back for flag
//	raising.
//	LB Button - button 5 and motorG, a DC motor. Controls the flag spinner motor to lower the flag.
//	RB Button - button 6 and motorG, a DC motor. Controls the flag spinner motor to raise the flag.
//	LT Button - button 7. When pressed, the servo with the scoop, slants forward to drop blocks
//	ahead of the robot.
//	RT Button - button 8. When pressed, the servo with the scoop, slants backward to grab blocks
//	into our control
//
//	Thanks for reading and have a nice day!
//	~Team 6150, the Fractals
//
// 	Last modified: Jan 20th, 2014
//
//
//	DOCUMENTATION AND CHANGES:
//	12/31/13 - Added this comment and others to explain code
//	01/11/14 - Added the encoder code to make arm and servo move together.
//	1/11/14 - Also tried to make servo and arm move at same time instead of
//	one before the other.
//	1/11/14 - Added variables to make changes easier.
//	1/11/14 - As of 3:30 pm, looking up the acceleration thing one kid suggested
//	1/20/14 -
//
//
//	@author - Subash C., Manu S., and Prathosh V.
//
/////////////////////////////////////////////////////////////////////////////////////


#include "JoystickDriver.c";

/**
*	Method stops all driver movement
* in case something goes wrong
*/
void stopAll()
{
	//Sets all motors to zero, stops robot
	motor[motorD] = 0;
	motor[motorE] = 0;
}

task main()
{
	while(true)
	{
		getJoystickSettings(joystick);

		int deadZone = 10; // deadzone number
		// defines the "null" area, where the robot won't move

		float armDiv = 4; // arm speed divisor
		float encoderDiv = 25; // encoder divisor for
		// servo and arm movement

		// Calls the stopAll() method to stop motors
		if(joy1Btn(2) == 1) // see stopAll() at line 81
			stopAll();

		// If trigger is pressed, speed up robot
		if(joy1Btn(6) == 1)
		{
			float driveDiv = 2;	// divisor to dampen drivetrain speed

			int leftSpeed = 0; // initialize left and right speeds for
			int rightSpeed = 0; // the drivetrain

			getJoystickSettings(joystick);
			if ( -deadZone > joystick.joy1_y1 > -100 || deadZone < joystick.joy1_y1 < 100) // if the value on base's y1 is not in the deadzone...
			{
				leftSpeed = joystick.joy1_y1 / driveDiv; // sets the speed for the left side
			}

			getJoystickSettings(joystick);
			if ( -deadZone > joystick.joy1_y2 > -100 || deadZone < joystick.joy1_y2 < 100) // if the value on base's y2 is not in the deadzone...
			{
				rightSpeed = joystick.joy1_y2 / driveDiv; // sets the speed for the right side
			}
			// sets the motors now so that they are
			// synchronized; otherwise, left would be in front
			motor[motorD] = leftSpeed;
			motor[motorE] = rightSpeed;

			if (-deadZone > joystick.joy2_y1 > -100 || deadZone < joystick.joy2_y1 < 100)
			{
				if(joy2Btn(6) == 1)
					motor[motorF] = joystick.joy2_y1 / 3; // arm controls
				else if(joy2Btn(6) != 1)
					motor[motorF] = joystick.joy2_y1 / armDiv; // arm controls
			}
			else{}

			// servo controls
			if(joy2Btn(7) == 1)
				servo[tip] = ServoValue[tip] + 2; // tips downward for drop in front
			else if(joy2Btn(8) == 1)
				servo[tip] = ServoValue[tip] - 2; // tips upward for drop behind

			if(-deadZone > joystick.joy2_y2 > -100 || deadZone < joystick.joy2_y2 < 100)
			{
				motor[motorG] = joystick.joy2_y2;
			}
		}

		// if trigger is not pressed, slow down robot
		// same as above, but slower
		else
		{
			float driveDiv = 4;

			getJoystickSettings(joystick);
			int leftSpeed = 0;
			int rightSpeed = 0;
			if (-deadZone > joystick.joy1_y1 > -100 || deadZone < joystick.joy1_y1 < 100)
			{
				leftSpeed = joystick.joy1_y1 / driveDiv;

			}
			getJoystickSettings(joystick);
			if (-deadZone > joystick.joy1_y2 > -100 || deadZone < joystick.joy1_y2 < 100)
			{
				rightSpeed = joystick.joy1_y2 / driveDiv;
			}

			motor[motorD] = leftSpeed;
			motor[motorE] = rightSpeed;

			getJoystickSettings(joystick);
			//if(joy2Btn(7) != 1 && joy2Btn(8) != 1)
			//{
			//	if (-deadZone > joystick.joy2_y1 > 100 || deadZone < joystick.joy2_y1 < 100)// if joy2's y1 is outside the deadzone...
			//	{
			//		motor[motorF] = joystick.joy2_y1 / armDiv; // set arm speed
			//	}
			//	servo[tip] = 255 - (nMotorEncoder[motorF] / encoderDiv); // divided encoder values
			//	// to get better results with servo and arm movement
			//}

			if (-deadZone > joystick.joy2_y1 > -100 || deadZone < joystick.joy2_y1 < 100)
			{
				if(joy2Btn(6) == 1)
					motor[motorF] = joystick.joy2_y1 / 3; // arm controls
				else if(joy2Btn(6) != 1)
					motor[motorF] = joystick.joy2_y1 / armDiv; // arm controls
			}
			else{}

			// servo controls
			if(joy2Btn(7) == 1)
				servo[tip] = ServoValue[tip] + 2; // tips downward for drop in front
			else if(joy2Btn(8) == 1)
				servo[tip] = ServoValue[tip] - 2; // tips upward for drop behind

			if(-deadZone > joystick.joy2_y2 > -100 || deadZone < joystick.joy2_y2 < 100)
			{
				motor[motorG] = joystick.joy2_y2;
			}
		}
	}
}
