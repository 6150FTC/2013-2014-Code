#pragma config(Hubs,  S1, HTMotor,  HTServo,  none,     none)
#pragma config(Hubs,  S2, HTMotor,  none,     none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     light,          sensorLightActive)
#pragma config(Sensor, S4,     IR,             sensorHiTechnicIRSeeker1200)
#pragma config(Motor,  motorA,          IRThing,       tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     motorF,        tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     motorG,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C1_1,     motorD,        tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S2_C1_2,     motorE,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C2_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_2,    tip,                  tServoStandard)
#pragma config(Servo,  srvo_S1_C2_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/////////////////////////////////////////////////////////////////////////////////////
//
//	BaseIRBackward (6150's Secondary Autonomous Program)
//
//	This file contains the autonomous program for team 6150, the Fractals.
//	We have left and right programs customized for our alliance member team(s). Our robot
//	first finds the IR beacon and drops one autonomous block into the corresponding basket,
//	which consistently scores. The second part of autonomous drives our robot onto the ramp
//	with enough space for another alliance member.
// 	In all, we can score 60 points in autonomous consistently and without flaws.
//
// 	Last modified: Jan 11th, 2014
//
//	DOCUMENTATION AND CHANGES:
//	12/31/13 - Added this comment and others to explain the code
//	1/11/14 - Some turns were wrong and were programmed for the forward auto,
//	now fixed as of 8:00 pm
//	1/14/14 - worked on precision for the backward moving IR sensing autonomous
//	and learned important coding standards
//
//	@author - Subash C., Manu S., and Prathosh V.
//
/////////////////////////////////////////////////////////////////////////////////////

#include "JoystickDriver.c"
#define driveIter_mS 25
#define turnIter_mS 25

/**
* Method finds the amount of turn needed to
* line up with the IR Sensor
*
* @return position - the amount of degrees the
* IR has turned
* NOTE - DEPRECATED
*/
int findPos()
{
	nMotorEncoder[IRThing] = 0;
	nMotorEncoderTarget[IRThing] = 180;
	motor[IRThing] = 10;
	while(nMotorRunState[IRThing] != runStateIdle)
	{
		if(SensorValue[IR] != 5){}
		else
		{
			//int position = nMotorEncoder[IRThing];
		}
	}
	int position = 0;
	return position;
}

/**
* Method finds the IR beacon and sets up for the drop() method
*
*	@return iterations - the number of times NXT has checked
* if IR beacon is in front
*/
int lineUp()
{
	// Using the light sensor to find a line
	//motor[motorD] = 50;
	//motor[motorE] = 50;
	//untilLight(50 , S3);
	//motor[motorD] = 0;
	//motor[motorE] = 0;
	// NOTE: THIS PART DEPRECATED

	// Not using this because we
	// found a way around this by lining up
	// parallel manually

	int searchZone = 4; // the zone that we are looking for
	int driveIterations = 0; // set the number of times checked to 0
	while(SensorValue(IR) != searchZone) // 4 for other side
	{
		if(SensorValue(IR) < searchZone) // if IR sensor is less than the searchZone ...
		{
			motor[motorD] = -50;
			motor[motorE] = -50;
			wait1Msec(driveIter_mS);
			//then move the robot backwards
			driveIterations++; // increment the times searched
		}

		else if(SensorValue(IR) > searchZone) // if IR sensor is more than the searchZone ...
		{
			motor[motorD] = 50;
			motor[motorE] = 50;
			wait1Msec(driveIter_mS);
			//then move the robot forwards
			driveIterations--; // decrement the times searched
		}

		else {break;}


	}
	return driveIterations;
}

int turn()
{
	int turnIterations = 0;

	// FREEZE!
	motor[motorD] = 0;
	motor[motorE] = 0;

	// this block moves the IR sensor straight
	nMotorEncoder[IRThing] = 0;
	nMotorEncoderTarget[IRThing] = 90;
	motor[IRThing] = -10;
	while(nMotorRunState[IRThing] != runStateIdle){}
	motor[IRThing] = 0;

	// keep turning until we are perpendicular to the basket
	while(SensorValue(IR) != 5) //always 4, because after first step,
	{ // forwards and backwards are the same
		motor[motorD] = -50;
		motor[motorE] = 50;
		wait1Msec(turnIter_mS);
		turnIterations++;
	}

	// Move forwards to basket
	motor[motorD] = 50;
	motor[motorE] = 50;
	wait1Msec(500);

	// STOP!
	motor[motorD] = 0;
	motor[motorE] = 0;
	wait1Msec(50);


	return turnIterations;
}

/**
*	Method drops the block into the basket
* Requires that robot is in front of basket
* SCORES 40 POINTS FOR BLOCK IN IR BASKET
*/
void drop()
{
	//move IR sensor into the robot for sensor safety
	nMotorEncoder[IRThing] = 0;
	nMotorEncoderTarget[IRThing] = 90;
	motor[IRThing] = -10;
	while(nMotorRunState[IRThing] != runStateIdle){}
	motor[IRThing] = 0;

	wait1Msec(100);
	motor[motorF] = 20; // dump that block!
	wait1Msec(1100);

	motor[motorF] = 0; // pause for clean drop
	wait1Msec(500);

	motor[motorF] = -20; // retract back
	wait1Msec(900);

	motor[motorF] = 0; // pause for clean transition
	wait1Msec(500);
}

/**
*	Method gets the robot from the basket to the ramp
*	Requires that the block has been dropped
*	SCORES 20 POINTS ON THE RAMP
*
* @param iterations - the number of times NXT has checked
* which basket the IR is under; each iteration is 100 milliseconds
*/
void ramp(int driveiterations)
{
	motor[motorD] = 50; // run backwards for iterations * 100 milliseconds
	motor[motorE] = 50; // because each iteration is 100 milliseconds long
	wait1Msec(driveIter_mS * (driveiterations - 3));

	motor[motorD] = -50; // turns toward the ramp
	motor[motorE] = 50;
	wait1Msec(1000);

	motor[motorD] = 50; // drives toward center of ramp
	motor[motorE] = 50;
	wait1Msec(3000);

	motor[motorD] = -50; // squares upto ramp
	motor[motorE] = 50;
	wait1Msec(1000);

	motor[motorD] = 100; // drive up onto ramp
	motor[motorE] = 100; // for a score!
	wait1Msec(2100);
}

task main()
{
	waitForStart(); // wait for the FCS to initiate autonomous

	int timesRun = lineUp(); // see line 75 for lineUp()
	int turnIterations = turn();
	// Drops the block into the basket
	drop(); // see line 150 for drop()

	// Move robot away from basket
	motor[motorD] = -50;
	motor[motorE] = -50;
	wait1Msec(500);

	// Spin robot parallel to teeter totter
	motor[motorD] = 50;
	motor[motorE] = -50;
	wait1Msec(turnIterations * turnIter_mS);// 25 * turnIterations

	// drives us onto the ramp
	ramp(timesRun); // see line 174 for ramp(timesRun)
}
